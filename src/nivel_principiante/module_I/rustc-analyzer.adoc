= üîß rustc y rust-analyzer: Herramientas Fundamentales de Rust
:source-highlighter: rouge
:rouge-style: monokai
:icons: font
:toc: left
:toclevels: 3
:toc-title: Contenido
:sectnums:
:experimental:

[abstract]
.Sobre este documento
====
Esta gu√≠a explica dos herramientas fundamentales del ecosistema Rust: *rustc* (el compilador) y *rust-analyzer* (el servidor de lenguaje).

Entender estas herramientas te ayudar√° a:

* Comprender c√≥mo funciona Rust internamente
* Depurar problemas de compilaci√≥n
* Aprovechar al m√°ximo tu editor
* Ser m√°s productivo en tu desarrollo diario

*Nivel*: Principiante a Intermedio +
*Tiempo de lectura*: 15-20 minutos
====

'''

= Parte 1: rustc - El Compilador de Rust

== ¬øQu√© es rustc?

*rustc* es el **compilador oficial de Rust**. Es el programa que transforma tu c√≥digo fuente (archivos `.rs`) en ejecutables que tu computadora puede ejecutar.

[NOTE]
====
Aunque usamos `cargo` en el d√≠a a d√≠a, internamente Cargo llama a `rustc` para compilar tu c√≥digo. Entender `rustc` te ayuda a comprender mejor lo que sucede "bajo el cap√≥".
====

=== Analog√≠a Simple

Imagina que escribes una receta en espa√±ol, pero tu horno solo entiende instrucciones en lenguaje de m√°quina. El compilador `rustc` es el traductor que convierte tu receta (c√≥digo Rust) en instrucciones que el horno (CPU) puede ejecutar.

.Proceso de Compilaci√≥n
[source,text]
----
C√≥digo Rust (.rs) ‚Üí rustc ‚Üí Binario Ejecutable (.exe o sin extensi√≥n)
      ‚Üì                ‚Üì              ‚Üì
  Legible por       Traductor    Ejecutable por
   humanos                       la computadora
----

'''

== ¬øPor Qu√© es Fundamental Entender rustc?

=== 1. Verificaci√≥n en Tiempo de Compilaci√≥n

Rust es famoso por detectar errores **antes** de que tu programa se ejecute. Esto lo hace `rustc`:

[cols="1,2", options="header"]
|===
|Tipo de Error
|Lo que rustc Verifica

|*Ownership*
|¬øHay m√∫ltiples due√±os de un valor?

|*Borrowing*
|¬øSe est√°n violando las reglas de pr√©stamo?

|*Tipos*
|¬øLos tipos coinciden correctamente?

|*Lifetimes*
|¬øLas referencias viven lo suficiente?

|*Concurrencia*
|¬øHay data races potenciales?
|===

.Ejemplo: rustc detectando un error
[source,rust,linenums]
----
fn main() {
    let x = 5;
    x = 10;  // <1>
}
----
<1> Error: `x` es inmutable por defecto

.Mensaje de error de rustc
[source,text]
----
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:3:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     x = 10;
  |     ^^^^^^ cannot assign twice to immutable variable
----

IMPORTANT: Los mensajes de error de `rustc` son **educativos**. No solo te dicen qu√© est√° mal, sino tambi√©n *por qu√©* y *c√≥mo arreglarlo*.

=== 2. Optimizaci√≥n Agresiva

`rustc` usa LLVM como backend, lo que le permite generar c√≥digo extremadamente optimizado:

[source,rust,linenums]
----
// C√≥digo que escribes
fn suma(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let resultado = suma(5, 3);
    println!("{}", resultado);
}
----

Cuando compiles con `--release`, `rustc`:

* Elimina c√≥digo muerto
* Inline funciones peque√±as
* Optimiza loops
* Reordena instrucciones para mejor uso de cach√©

=== 3. Seguridad sin Costo en Runtime

Rust verifica todo en *tiempo de compilaci√≥n*, no en *tiempo de ejecuci√≥n*:

[cols="1,1,1", options="header"]
|===
|Lenguaje
|Verificaci√≥n
|Costo

|*Java/Python*
|Runtime (mientras se ejecuta)
|‚ùå M√°s lento

|*C/C++*
|Ninguna
|‚ö†Ô∏è Peligroso

|*Rust*
|Compile-time (antes de ejecutar)
|‚úÖ R√°pido y seguro
|===

'''

== Uso B√°sico de rustc

=== Compilar un Archivo Simple

.Crear un archivo main.rs
[source,rust]
----
fn main() {
    println!("¬°Hola desde rustc!");
}
----

.Compilar con rustc
[source,bash]
----
rustc main.rs
----

Esto genera:

* **Windows**: `main.exe`
* **Linux/macOS**: `main`

.Ejecutar el programa
[source,bash]
----
# Windows
.\main.exe

# Linux/macOS
./main
----

=== Opciones Comunes de rustc

==== Especificar el Nombre del Ejecutable

[source,bash]
----
rustc main.rs -o mi_programa
----

==== Nivel de Optimizaci√≥n

[source,bash]
----
rustc main.rs -O           # <1>
rustc main.rs -C opt-level=3  # <2>
----
<1> Optimizaci√≥n b√°sica
<2> M√°xima optimizaci√≥n (equivalente a `cargo build --release`)

==== Ver Warnings

[source,bash]
----
rustc main.rs -W unused-variables  # <1>
rustc main.rs -W help              # <2>
----
<1> Advertir sobre variables no usadas
<2> Ver todos los warnings disponibles

==== Informaci√≥n de Debugging

[source,bash]
----
rustc main.rs -g  # Incluye s√≠mbolos de debug
----

'''

== C√≥mo Funciona rustc (Internamente)

rustc procesa tu c√≥digo en varias etapas:

.Fases de Compilaci√≥n
[source,text]
----
1. Lexing       ‚Üí Convierte texto en tokens
2. Parsing      ‚Üí Crea el AST (Abstract Syntax Tree)
3. Expansion    ‚Üí Expande macros
4. Resolution   ‚Üí Resuelve nombres y paths
5. Type Check   ‚Üí Verifica tipos y borrow checker
6. MIR          ‚Üí Mid-level Intermediate Representation
7. LLVM IR      ‚Üí Representaci√≥n de LLVM
8. Codegen      ‚Üí C√≥digo m√°quina nativo
----

[NOTE]
====
No necesitas entender cada fase en detalle, pero saber que existen te ayuda a:

* Entender mensajes de error
* Usar herramientas como `cargo expand`
* Depurar problemas complejos
====

=== Ejemplo: Ver el AST de tu C√≥digo

[source,bash]
----
rustc -Z ast main.rs  # Requiere nightly
----

'''

== rustc vs Cargo

[cols="1,2,2", options="header"]
|===
|
|rustc
|Cargo

|*Qu√© es*
|Compilador (herramienta de bajo nivel)
|Build system y gestor de paquetes

|*Uso t√≠pico*
|Archivos simples, experimentaci√≥n
|Proyectos reales

|*Gesti√≥n de deps*
|‚ùå No
|‚úÖ S√≠

|*Build profiles*
|Manual
|Autom√°tico (dev/release)

|*Testing*
|‚ùå No integrado
|‚úÖ `cargo test`

|*Cu√°ndo usar*
|Aprender, scripts peque√±os
|Siempre en proyectos reales
|===

TIP: En la pr√°ctica, *siempre usa Cargo* para proyectos reales. Solo usa `rustc` directamente para:
* Experimentar con flags espec√≠ficos
* Entender c√≥mo funciona internamente
* Scripts de un solo archivo

'''

= Parte 2: rust-analyzer - El Language Server

== ¬øQu√© es un Language Server?

Antes de hablar de `rust-analyzer`, entendamos qu√© es un **Language Server Protocol (LSP)**.

=== El Problema que Resuelve LSP

Imagina que tienes 5 editores diferentes (VS Code, Vim, Emacs, Sublime, Atom) y 10 lenguajes de programaci√≥n. Sin LSP necesitar√≠as:

.Sin LSP
[source,text]
----
5 editores √ó 10 lenguajes = 50 integraciones diferentes üò±
----

Con LSP, cada lenguaje implementa *un solo servidor* y cada editor implementa *un solo cliente*:

.Con LSP
[source,text]
----
5 editores + 10 servidores = 15 implementaciones üéâ
----

=== ¬øC√≥mo Funciona?

.Arquitectura LSP
[source,text]
----
Editor (VS Code, Vim, etc.)
    ‚ÜïÔ∏è  (comunicaci√≥n JSON-RPC)
Language Server (rust-analyzer)
    ‚ÜïÔ∏è
An√°lisis del c√≥digo Rust
----

Cuando escribes c√≥digo:

. El editor env√≠a tu c√≥digo al servidor
. El servidor lo analiza
. El servidor responde con:
** Errores y warnings
** Sugerencias de autocompletado
** Informaci√≥n de tipos
** Definiciones de funciones
** Etc.

'''

== ¬øQu√© es rust-analyzer?

*rust-analyzer* es el **Language Server oficial de Rust**. Es el "cerebro" que hace que tu editor entienda Rust.

[IMPORTANT]
====
No confundir con:

* *rustc*: El compilador (transforma c√≥digo en ejecutable)
* *rust-analyzer*: El servidor de lenguaje (ayuda mientras escribes)
====

=== Caracter√≠sticas Principales

==== 1. Autocompletado Inteligente

Cuando escribes:

[source,rust]
----
let nombre = String::from("Rust");
nombre.  // <1>
----
<1> rust-analyzer muestra todos los m√©todos de String

.Ejemplo de autocompletado
[source,text]
----
nombre.len()           ‚Üí usize
nombre.push_str(s)     ‚Üí ()
nombre.to_uppercase()  ‚Üí String
nombre.chars()         ‚Üí Chars<'_>
...y muchos m√°s
----

==== 2. Informaci√≥n de Tipos en L√≠nea

[source,rust,linenums]
----
fn suma(a: i32, b: i32) -> i32 {
    let resultado = a + b;  // rust-analyzer muestra: i32
    resultado
}
----

rust-analyzer te muestra el tipo de `resultado` sin que tengas que anotarlo.

==== 3. Go to Definition

kbd:[F12] o kbd:[Ctrl+Click] en cualquier funci√≥n/tipo/variable para saltar a su definici√≥n.

[source,rust]
----
use std::collections::HashMap;

fn main() {
    let mut mapa = HashMap::new();  // <1>
    //              ‚Üë Click aqu√≠
}
----
<1> Te lleva directamente al c√≥digo fuente de `HashMap::new()`

==== 4. Errores en Tiempo Real

No necesitas compilar para ver errores:

[source,rust]
----
fn main() {
    let x: i32 = "hola";  // ‚ö†Ô∏è Error inmediato
    //           ~~~~~~
    //           expected `i32`, found `&str`
}
----

==== 5. Refactorings Autom√°ticos

* Renombrar s√≠mbolos (kbd:[F2])
* Extraer funciones
* Implementar traits autom√°ticamente
* A√±adir imports faltantes

==== 6. Documentaci√≥n Inline

Hover sobre cualquier funci√≥n para ver su documentaci√≥n:

[source,rust]
----
let v = vec![1, 2, 3];
v.push(4);  // <1>
//  ‚Üë Hover aqu√≠
----
<1> Muestra: "Appends an element to the back of a collection"

'''

== ¬øPor Qu√© es Fundamental rust-analyzer?

=== 1. Productividad 10x

Sin rust-analyzer:

* ‚ùå Escribes c√≥digo a ciegas
* ‚ùå Esperas compilar para ver errores
* ‚ùå Buscas documentaci√≥n manualmente
* ‚ùå Escribes imports a mano

Con rust-analyzer:

* ‚úÖ Ves errores instant√°neamente
* ‚úÖ Autocompletado inteligente
* ‚úÖ Documentaci√≥n al instante
* ‚úÖ Imports autom√°ticos

=== 2. Curva de Aprendizaje M√°s Suave

rust-analyzer es como tener un tutor de Rust al lado:

[source,rust,linenums]
----
fn main() {
    let s = String::from("hola");
    let s2 = s;        // <1>
    println!("{}", s); // <2>
}
----
<1> rust-analyzer te advierte que `s` se movi√≥
<2> Error inmediato: "value borrowed here after move"

=== 3. Exploraci√≥n del C√≥digo

Puedes explorar el standard library sin salir del editor:

* kbd:[F12] en `Vec::new()` ‚Üí Ver implementaci√≥n
* kbd:[Ctrl+Shift+O] ‚Üí Buscar s√≠mbolos en el proyecto
* kbd:[Ctrl+T] ‚Üí Buscar tipos en todas las dependencias

'''

== Instalaci√≥n y Configuraci√≥n

=== Verificar Instalaci√≥n

rust-analyzer se instala autom√°ticamente con rustup moderno:

[source,bash]
----
rustup component add rust-analyzer
----

=== Configuraci√≥n por Editor

==== VS Code

. Instala la extensi√≥n: *rust-analyzer*
. La extensi√≥n descarga el servidor autom√°ticamente

==== Vim/Neovim

Con CoC.nvim:

[source,vim]
----
:CocInstall coc-rust-analyzer
----

Con nvim-lspconfig:

[source,lua]
----
require'lspconfig'.rust_analyzer.setup{}
----

==== Emacs

[source,elisp]
----
(use-package rust-mode)
(use-package lsp-mode
  :hook (rust-mode . lsp))
----

==== Zed

rust-analyzer viene preinstalado en Zed.

'''

== Configuraci√≥n Avanzada

=== Archivo de Configuraci√≥n

Crea `.vscode/settings.json` (VS Code) o equivalente:

[source,json,linenums]
----
{
  "rust-analyzer.checkOnSave.command": "clippy",  // <1>
  "rust-analyzer.cargo.allFeatures": true,        // <2>
  "rust-analyzer.inlayHints.typeHints": true,     // <3>
  "rust-analyzer.lens.implementations": true      // <4>
}
----
<1> Usa Clippy en lugar de `cargo check`
<2> Habilita todas las features
<3> Muestra tipos en l√≠nea
<4> Muestra d√≥nde se implementa cada trait

=== Opciones √ötiles

[cols="2,3", options="header"]
|===
|Opci√≥n
|Descripci√≥n

|`checkOnSave.command`
|Comando para verificar (`check`, `clippy`, `test`)

|`cargo.features`
|Features espec√≠ficas a habilitar

|`inlayHints.*`
|Hints de tipos, par√°metros, etc.

|`lens.*`
|CodeLens (references, implementations)

|`procMacro.enable`
|Habilitar expansi√≥n de macros procedurales
|===

'''

== Diferencias Clave: rustc vs rust-analyzer

[cols="1,2,2", options="header"]
|===
|
|rustc
|rust-analyzer

|*Prop√≥sito*
|Compilar c√≥digo a binario
|An√°lisis en tiempo real

|*Cu√°ndo act√∫a*
|Solo al compilar
|Mientras escribes

|*Velocidad*
|M√°s lento (compilaci√≥n completa)
|Muy r√°pido (an√°lisis incremental)

|*Precisi√≥n*
|100% (es el compilador oficial)
|~99% (puede tener falsos positivos)

|*Output*
|Ejecutable
|Informaci√≥n para el editor

|*Uso*
|Via `cargo build`/`rustc`
|Via tu editor

|*Errores*
|Finales y definitivos
|Ayuda mientras escribes
|===

[NOTE]
====
rust-analyzer usa partes de rustc internamente, pero est√° optimizado para an√°lisis incremental r√°pido, no para generar ejecutables.
====

'''

== Casos de Uso Pr√°cticos

=== Escenario 1: Debugging de Ownership

[source,rust,linenums]
----
fn main() {
    let s1 = String::from("hola");
    let s2 = s1;  // <1>

    println!("{}", s1);  // <2>
}
----
<1> rust-analyzer muestra: ‚ìò value moved here
<2> rust-analyzer muestra: ‚ö†Ô∏è value used after move

*Sin rust-analyzer*: Tendr√≠as que compilar para ver el error.

*Con rust-analyzer*: Lo ves inmediatamente, incluso antes de salvar el archivo.

=== Escenario 2: Explorando APIs

Quieres usar `HashMap` pero no recuerdas los m√©todos:

[source,rust]
----
use std::collections::HashMap;

fn main() {
    let mut mapa = HashMap::new();
    mapa.  // <1>
}
----
<1> rust-analyzer te muestra TODOS los m√©todos disponibles

Puedes explorar la API sin salir del editor ni consultar docs externas.

=== Escenario 3: Refactoring Seguro

Necesitas renombrar una variable en 50 archivos:

. Coloca el cursor en la variable
. Presiona kbd:[F2]
. Escribe el nuevo nombre
. rust-analyzer renombra *todas* las ocurrencias, incluso en otros archivos

*Garantizado* que no romper√°s nada.

'''

== Soluci√≥n de Problemas

=== rust-analyzer No Funciona

==== Problema 1: No encuentra el proyecto

[source,bash]
----
# Aseg√∫rate de abrir el editor en la ra√≠z del proyecto
cd mi_proyecto
code .  # VS Code
nvim .  # Neovim
----

==== Problema 2: Muy lento

.Verifica el tama√±o del proyecto
[source,bash]
----
# Si target/ es muy grande
cargo clean

# O excluye target/ del an√°lisis
----

.Configuraci√≥n para proyectos grandes
[source,json]
----
{
  "rust-analyzer.cargo.buildScripts.enable": false,
  "rust-analyzer.procMacro.enable": false
}
----

==== Problema 3: Errores fantasma

.Reinicia el servidor
* VS Code: kbd:[Ctrl+Shift+P] ‚Üí "Restart Language Server"
* Vim: `:LspRestart`

=== Logs para Debugging

.Ver logs de rust-analyzer
[source,bash]
----
# Linux/macOS
tail -f ~/.local/state/rust-analyzer/server.log

# Windows
# Ver en: %APPDATA%\rust-analyzer\logs\
----

'''

== Mejores Pr√°cticas

=== 1. Usa Cargo Siempre

[source,bash]
----
# ‚úÖ Correcto
cargo new mi_proyecto
cd mi_proyecto

# ‚ùå Evitar (rust-analyzer puede no funcionar bien)
rustc main.rs
----

rust-analyzer est√° dise√±ado para trabajar con proyectos Cargo.

=== 2. Mant√©n rust-analyzer Actualizado

[source,bash]
----
rustup update
# rust-analyzer se actualiza autom√°ticamente
----

=== 3. Configura Clippy como Checker

[source,json]
----
{
  "rust-analyzer.checkOnSave.command": "clippy"
}
----

Obtendr√°s sugerencias de estilo adem√°s de errores.

=== 4. Aprovecha los Hints

No los desactives al principio. Te ense√±an mucho sobre Rust:

[source,json]
----
{
  "rust-analyzer.inlayHints.typeHints": true,
  "rust-analyzer.inlayHints.parameterHints": true,
  "rust-analyzer.inlayHints.chainingHints": true
}
----

=== 5. Usa CodeLens

[source,json]
----
{
  "rust-analyzer.lens.references": true,
  "rust-analyzer.lens.implementations": true,
  "rust-analyzer.lens.run": true
}
----

Te permite ver:
* D√≥nde se usa una funci√≥n
* D√≥nde se implementa un trait
* Bot√≥n "Run" sobre funciones main/tests

'''

== Comandos √ötiles del D√≠a a D√≠a

[cols="2,3,2", options="header"]
|===
|Atajo (VS Code)
|Acci√≥n
|Cu√°ndo Usar

|kbd:[F12]
|Go to Definition
|Explorar c√≥digo

|kbd:[Alt+F12]
|Peek Definition
|Ver sin cambiar de archivo

|kbd:[Shift+F12]
|Find All References
|Ver d√≥nde se usa algo

|kbd:[F2]
|Rename Symbol
|Refactoring

|kbd:[Ctrl+Space]
|Trigger Completion
|Forzar autocompletado

|kbd:[Ctrl+Shift+O]
|Go to Symbol
|Navegar en archivo

|kbd:[Ctrl+T]
|Go to Symbol in Workspace
|Buscar en todo el proyecto

|kbd:[Ctrl+.]
|Quick Fix
|Aplicar sugerencias
|===

'''

== Comparaci√≥n Visual

.Flujo de Trabajo SIN rust-analyzer
[source,text]
----
1. Escribir c√≥digo
2. Guardar archivo
3. Ejecutar: cargo check
4. Esperar... ‚è≥
5. Ver errores en terminal
6. Volver al c√≥digo
7. Repetir...
----

.Flujo de Trabajo CON rust-analyzer
[source,text]
----
1. Escribir c√≥digo
2. Ver errores inmediatamente ‚ö°
3. Autocompletado inteligente
4. Documentaci√≥n inline
5. Refactorings autom√°ticos
6. Compilar solo cuando est√© listo ‚úÖ
----

'''

== Resumen y Conclusiones

=== rustc: El Compilador

[cols="1,2", options="header"]
|===
|Qu√© Hace
|Por Qu√© Importa

|Traduce Rust a ejecutable
|Sin √©l, no hay programa

|Verifica seguridad
|Previene bugs antes de ejecutar

|Optimiza c√≥digo
|Rendimiento comparable a C

|Mensajes de error educativos
|Te ense√±a mientras aprendes
|===

=== rust-analyzer: Tu Asistente

[cols="1,2", options="header"]
|===
|Qu√© Hace
|Por Qu√© Importa

|An√°lisis en tiempo real
|Feedback instant√°neo

|Autocompletado inteligente
|10x m√°s productivo

|Navegaci√≥n de c√≥digo
|Explorar sin salir del editor

|Refactorings seguros
|Cambios sin miedo
|===

=== Relaci√≥n Entre Ambos

[source,text]
----
Mientras escribes c√≥digo:
    rust-analyzer te ayuda y muestra errores

Cuando quieres ejecutar:
    cargo llama a rustc
    rustc compila tu c√≥digo
    Obtienes un ejecutable
----

[IMPORTANT]
====
*No son competidores, son complementarios:*

* *rustc* = El que realmente compila
* *rust-analyzer* = Tu asistente mientras programas
====

'''

== Pr√≥ximos Pasos

. ‚úÖ Instala rust-analyzer en tu editor favorito
. ‚úÖ Explora las opciones de configuraci√≥n
. ‚úÖ Practica usando los atajos de teclado
. ‚úÖ Lee los mensajes de error de rustc con atenci√≥n
. ‚úÖ Experimenta con `cargo expand` para ver expansi√≥n de macros

'''

[quote, Rust Community]
____
*rustc* y *rust-analyzer* son el coraz√≥n del desarrollo en Rust.

rustc te da seguridad y rendimiento. +
rust-analyzer te da productividad y feedback instant√°neo.

Juntos, hacen de Rust una experiencia de desarrollo √∫nica.
____

[.text-center]
*Siguiente tema*: Variables y Mutabilidad (`let` y `let mut`) ‚Üí
