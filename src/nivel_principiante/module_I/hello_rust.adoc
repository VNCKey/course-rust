= üëã Hola Mundo en Rust
:source-highlighter: rouge
:rouge-style: monokai
:icons: font
:toc: left
:toclevels: 3
:toc-title: Contenido
:sectnums:
:experimental:

== Introducci√≥n

Rust se integra perfectamente con *Cargo*, su herramienta oficial para gestionar proyectos, dependencias y compilaciones. Gracias a Cargo, crear, construir y ejecutar programas se vuelve mucho m√°s sencillo y organizado.

TIP: Cargo es equivalente a `npm` en JavaScript, `pip` en Python o `maven` en Java, pero todo integrado en una sola herramienta.

'''

== Creando tu Primer Proyecto

=== Comando de creaci√≥n

En la terminal, ejecuta:

[source,bash]
----
cargo new mundorust
----

Este comando crea un nuevo proyecto desde cero con la estructura b√°sica lista para programar.

[source,bash]
----
cd mundorust
----

=== Estructura del proyecto generado

Cargo crea autom√°ticamente esta estructura:

.√Årbol de archivos generado
----
mundorust/
‚îú‚îÄ‚îÄ Cargo.toml      # <1>
‚îú‚îÄ‚îÄ .gitignore      # <2>
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ main.rs     # <3>
----
<1> Archivo de configuraci√≥n del proyecto (metadatos y dependencias)
<2> Git configurado autom√°ticamente para ignorar archivos compilados
<3> Archivo principal que contiene la funci√≥n `main()`

'''

== Anatom√≠a del Proyecto

=== El archivo `Cargo.toml`

Este es el coraz√≥n de tu proyecto. Define metadatos y dependencias:

.Contenido inicial de Cargo.toml
[source,toml,linenums]
----
[package]
name = "mundorust"
version = "0.1.0"
edition = "2021"

[dependencies]
# Las dependencias van aqu√≠
----

.*Secciones principales:*

`[package]`::
Contiene los metadatos del proyecto:
* `name`: Nombre del proyecto
* `version`: Versi√≥n siguiendo https://semver.org/[Semantic Versioning]
* `edition`: Edici√≥n estable de Rust (actualmente 2021)
* Opcionalmente: `authors`, `description`, `license`

`[dependencies]`::
Lista las bibliotecas externas (_crates_) que necesita tu proyecto. Cargo las descarga y gestiona autom√°ticamente.

.Ejemplo con dependencias
[source,toml,linenums,highlight=7]
----
[package]
name = "mundorust"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8"  # <1>
serde = { version = "1.0", features = ["derive"] }  # <2>
----
<1> Librer√≠a para generar n√∫meros aleatorios
<2> Librer√≠a de serializaci√≥n con caracter√≠sticas adicionales

=== El punto de entrada: `main.rs`

El archivo `src/main.rs` contiene el c√≥digo inicial:

.Contenido de src/main.rs
[source,rust,linenums]
----
fn main() {  // <1>
    println!("Hello, world!");  // <2>
}  // <3>
----
<1> `fn main()` define la funci√≥n principal del programa (punto de entrada)
<2> `println!()` es una *macro* que imprime texto en la consola
<3> Las llaves `{ }` delimitan el bloque de c√≥digo de la funci√≥n

[NOTE]
====
*Diferencias clave:*

* `println!` con `!` es una *macro*, no una funci√≥n
* Las macros en Rust se expanden en tiempo de compilaci√≥n
* `println!` soporta formato de texto similar a `printf` en C
====

'''

== Compilaci√≥n Simple sin Cargo

Para pruebas r√°pidas o aprendizaje, puedes usar el compilador directamente:

[source,bash]
----
rustc main.rs
----

Esto genera un ejecutable en el directorio actual.

=== Ejecutar el binario generado

.*En Windows:*
[source,powershell]
----
.\main.exe
----

.*En Linux/macOS:*
[source,bash]
----
./main
----

.*Resultado esperado:*
[source,text]
----
Hello, world!
----

WARNING: Compilar con `rustc` directamente es √∫til para aprender, pero para proyectos reales *siempre usa Cargo*. Cargo gestiona dependencias, optimizaciones y estructura del proyecto autom√°ticamente.

'''

== Compilar y Ejecutar con Cargo

=== Comando principal: `cargo run`

Dentro de la carpeta del proyecto, compila y ejecuta en un solo paso:

[source,bash]
----
cargo run
----

.*Salida t√≠pica:*
[source,text,linenums]
----
   Compiling mundorust v0.1.0 (D:\VNC\RUST\mundorust)  // <1>
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.42s  // <2>
     Running `target\debug\mundorust.exe`  // <3>
Hello, world!  // <4>
----
<1> Cargo compila el proyecto (solo la primera vez o si hay cambios)
<2> Perfil de compilaci√≥n usado: `dev` (desarrollo, sin optimizaciones)
<3> Ruta del ejecutable que se est√° ejecutando
<4> Output de tu programa

[TIP]
====
Si no modificaste el c√≥digo, la segunda vez que ejecutes `cargo run` ser√° instant√°neo:

[source,text]
----
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `target\debug\mundorust.exe`
Hello, world!
----

Cargo solo recompila lo que cambi√≥ (*compilaci√≥n incremental*).
====

=== Solo compilar: `cargo build`

√ötil para verificar que el proyecto compila sin ejecutarlo:

[source,bash]
----
cargo build
----

El binario se genera en `target/debug/`:

[cols="1,2", options="header"]
|===
|Sistema
|Ubicaci√≥n del ejecutable

|Windows
|`target\debug\mundorust.exe`

|Linux/macOS
|`target/debug/mundorust`
|===

Puedes ejecutarlo manualmente despu√©s:

[source,bash]
----
./target/debug/mundorust  # Linux/macOS
.\target\debug\mundorust.exe  # Windows
----

'''

== Comandos de Desarrollo

=== Verificaci√≥n r√°pida: `cargo check`

El comando m√°s r√°pido durante el desarrollo:

[source,bash]
----
cargo check
----

[cols="1,1", options="header"]
|===
|`cargo build`
|`cargo check`

|Compila completamente
|Solo verifica errores

|Genera ejecutable
|No genera ejecutable

|~3-10 segundos
|~0.5-2 segundos

|Uso: antes de ejecutar
|Uso: mientras editas
|===

.*¬øCu√°ndo usar `cargo check`?*

* icon:check[] Mientras escribes c√≥digo
* icon:check[] Para verificar sintaxis r√°pidamente
* icon:check[] Si olvidaste un `;` o cerraste mal una llave `{ }`
* icon:check[] Antes de hacer commit

.*Ejemplo de error detectado:*
[source,rust,linenums,highlight=2]
----
fn main() {
    let x = 5  // <1>
    println!("{}", x);
}
----
<1> ¬°Falta el punto y coma!

[source,text]
----
error: expected `;`, found `println`
 --> src/main.rs:3:5
  |
2 |     let x = 5
  |              ^ help: add `;` here
3 |     println!("{}", x);
  |     ^^^^^^^ expected `;`
----

=== Limpiar compilaciones: `cargo clean`

Elimina todos los archivos generados en `target/`:

[source,bash]
----
cargo clean
----

.*¬øCu√°ndo usar?*

* Liberar espacio en disco (la carpeta `target/` puede ocupar cientos de MB)
* Forzar una recompilaci√≥n completa desde cero
* Antes de comprimir/compartir el proyecto

NOTE: Despu√©s de `cargo clean`, la pr√≥xima compilaci√≥n ser√° m√°s lenta porque Cargo debe recompilar todo desde cero.

'''

== Compilaci√≥n para Producci√≥n

=== Release build: `cargo build --release`

Cuando necesites un binario optimizado para distribuir:

[source,bash]
----
cargo build --release
----

El ejecutable optimizado se genera en `target/release/`.

.Diferencias entre perfiles
[cols="1,2,2", options="header"]
|===
|
|Debug (`cargo build`)
|Release (`cargo build --release`)

|*Optimizaci√≥n*
|Ninguna (m√°s r√°pido de compilar)
|M√°xima (O3, LTO opcional)

|*Velocidad de ejecuci√≥n*
|Puede ser 10-100x m√°s lenta
|M√°ximo rendimiento

|*Tama√±o del binario*
|M√°s grande (incluye debug info)
|M√°s peque√±o (stripped)

|*Tiempo de compilaci√≥n*
|R√°pido (~3-10s)
|Lento (~10-60s)

|*Debugging*
|Completo (con s√≠mbolos)
|Limitado

|*Ubicaci√≥n*
|`target/debug/`
|`target/release/`

|*Cu√°ndo usar*
|Desarrollo diario
|Producci√≥n, distribuci√≥n, benchmarks
|===

IMPORTANT: Siempre usa `--release` para medir el rendimiento real de tu c√≥digo. El modo debug puede ser √≥rdenes de magnitud m√°s lento.

.*Ejemplo de diferencia de rendimiento:*
[source,text]
----
Debug:   Proces√≥ 1M elementos en 850ms
Release: Proces√≥ 1M elementos en 12ms  (70x m√°s r√°pido!)
----

'''

== Resumen de Comandos Cargo

.Comandos esenciales de Cargo
[cols="2,3,3", options="header"]
|===
|Comando
|Uso principal
|Cu√°ndo usarlo

|`cargo new <name>`
|Crea un nuevo proyecto con estructura b√°sica
|Inicio de cualquier proyecto

|`cargo run`
|Compila y ejecuta en un paso
|Desarrollo diario, pruebas r√°pidas

|`cargo build`
|Solo compila (sin ejecutar)
|Verificar c√≥digo sin correrlo

|`cargo check`
|Chequea errores de sintaxis/tipos (muy r√°pido)
|Iteraci√≥n constante mientras editas

|`cargo clean`
|Borra archivos generados en `target/`
|Liberar espacio o recompilar limpio

|`cargo build --release`
|Compila optimizado para producci√≥n
|Distribuir o medir rendimiento real

|`cargo test`
|Ejecuta tests del proyecto
|Desarrollo basado en tests (TDD)

|`cargo doc --open`
|Genera y abre documentaci√≥n
|Consultar docs de dependencias
|===

TIP: Ejecuta `cargo --help` para ver todos los comandos disponibles, o `cargo <comando> --help` para ayuda espec√≠fica.

'''

== Flujo de Trabajo T√≠pico

=== Desarrollo d√≠a a d√≠a

[source,bash,linenums]
----
# 1. Crear proyecto
cargo new mi_app

# 2. Entrar al proyecto
cd mi_app

# 3. Editar c√≥digo en src/main.rs
# ... (usar tu editor favorito)

# 4. Verificar errores (muy r√°pido)
cargo check

# 5. Compilar y ejecutar
cargo run

# 6. Repetir pasos 3-5 hasta terminar

# 7. Compilar versi√≥n optimizada final
cargo build --release
----

=== A√±adir dependencias

[source,bash]
----
# Opci√≥n 1: Editar Cargo.toml manualmente
# Agregar: rand = "0.8"

# Opci√≥n 2: Usar cargo add (Rust 1.62+)
cargo add rand
----

Cargo descarga autom√°ticamente las dependencias la pr√≥xima vez que compiles.

'''

== Pr√≥ximos Pasos

Ahora que sabes crear y compilar programas en Rust, est√°s listo para aprender:

* Variables y mutabilidad (`let` vs `let mut`)
* Tipos de datos
* Funciones
* Control de flujo
* Ownership (el concepto m√°s importante de Rust)

'''

== Recursos Adicionales

* üìñ https://doc.rust-lang.org/cargo/[Documentaci√≥n oficial de Cargo]
* ü¶Ä https://doc.rust-lang.org/book/ch01-03-hello-cargo.html[The Rust Book - Hello Cargo]
* üí¨ https://users.rust-lang.org/[Foro de la comunidad]
* üéØ https://play.rust-lang.org/[Rust Playground] - Prueba c√≥digo online

'''

[quote, Rust Community]
____
üéâ ¬°Felicitaciones! Has compilado tu primer programa en Rust. +
Cargo ser√° tu compa√±ero constante en este viaje. Aprende a dominarlo y ser√°s mucho m√°s productivo.
____

*Siguiente tema*: Variables y Mutabilidad (`let` y `let mut`) ‚Üí
