= ğŸ“¦ Cargo y Tu Primer Programa en Rust
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: rouge
:rouge-style: monokai
:experimental:

[abstract]
.Sobre este mÃ³dulo
====
En este mÃ³dulo aprenderÃ¡s:

* QuÃ© es Cargo y por quÃ© es fundamental
* CÃ³mo crear y estructurar proyectos
* Compilar y ejecutar tu primer programa
* Comandos esenciales para el desarrollo diario
* GestiÃ³n de dependencias

*Tiempo estimado*: 30-45 minutos
====

'''

== Â¿QuÃ© es Cargo?

*Cargo* es el sistema de compilaciÃ³n y gestor de paquetes oficial de Rust. Es una herramienta fundamental que simplifica todo el ciclo de desarrollo, desde la creaciÃ³n de proyectos hasta la gestiÃ³n de dependencias y la compilaciÃ³n.

Cargo se instala automÃ¡ticamente cuando instalas Rust a travÃ©s de `rustup`.

=== Â¿Por quÃ© es importante Cargo?

En otros lenguajes, necesitas mÃºltiples herramientas:

* *C/C++*: `make`, `cmake`, `pkg-config`
* *JavaScript*: `npm` o `yarn` + `webpack`
* *Python*: `pip` + `setuptools` + `virtualenv`

.*En Rust, Cargo lo hace todo:*
[%hardbreaks]
âœ… Crea y estructura proyectos
âœ… Compila tu cÃ³digo
âœ… Descarga y gestiona dependencias
âœ… Ejecuta tests
âœ… Genera documentaciÃ³n
âœ… Publica paquetes en https://crates.io[crates.io]

'''

== ğŸš€ Tu Primer Proyecto con Cargo

=== Crear un nuevo proyecto

[source,bash]
----
# Crear un proyecto binario (aplicaciÃ³n)
cargo new hola_mundo

# Entrar al directorio
cd hola_mundo
----

TIP: Usa nombres en snake_case (letras minÃºsculas con guiones bajos) para los proyectos.

=== Estructura del proyecto generado

Cargo crea automÃ¡ticamente esta estructura:

.Ãrbol de archivos generado
----
hola_mundo/
â”œâ”€â”€ Cargo.toml      # <1>
â”œâ”€â”€ .gitignore      # <2>
â””â”€â”€ src/
    â””â”€â”€ main.rs     # <3>
----
<1> Archivo de configuraciÃ³n del proyecto (metadatos y dependencias)
<2> Git configurado automÃ¡ticamente para ignorar archivos compilados
<3> Archivo principal que contiene la funciÃ³n `main()`

[NOTE]
====
Cargo inicializa automÃ¡ticamente un repositorio Git. Si no quieres esto, usa:

[source,bash]
----
cargo new hola_mundo --vcs none
----
====

'''

== ğŸ“ AnatomÃ­a del Proyecto

=== El archivo `Cargo.toml`

Este es el corazÃ³n de tu proyecto. Define metadatos y dependencias:

.Contenido inicial de Cargo.toml
[source,toml,linenums]
----
[package]
name = "hola_mundo"
version = "0.1.0"
edition = "2021"

[dependencies]
# Las dependencias van aquÃ­
----

.*Secciones principales:*

`[package]`::
Contiene los metadatos del proyecto:
* `name`: Nombre del proyecto
* `version`: VersiÃ³n siguiendo https://semver.org/[Semantic Versioning]
* `edition`: EdiciÃ³n estable de Rust (actualmente 2021)
* Opcionalmente: `authors`, `description`, `license`

`[dependencies]`::
Lista las bibliotecas externas (_crates_) que necesita tu proyecto. Cargo las descarga y gestiona automÃ¡ticamente.

=== El punto de entrada: `main.rs`

El archivo `src/main.rs` contiene el cÃ³digo inicial:

.Contenido de src/main.rs
[source,rust,linenums]
----
fn main() {  // <1>
    println!("Hello, world!");  // <2>
}  // <3>
----
<1> `fn main()` define la funciÃ³n principal del programa (punto de entrada)
<2> `println!()` es una *macro* que imprime texto en la consola
<3> Las llaves `{ }` delimitan el bloque de cÃ³digo de la funciÃ³n

[NOTE]
====
*Diferencias clave:*

* `println!` con `!` es una *macro*, no una funciÃ³n
* Las macros en Rust se expanden en tiempo de compilaciÃ³n
* `println!` soporta formato de texto similar a `printf` en C
====

'''

== âš¡ Compilar y Ejecutar

=== OpciÃ³n 1: Con Cargo (Recomendado)

==== Compilar y ejecutar en un solo paso

[source,bash]
----
cargo run
----

.*Salida tÃ­pica en la primera ejecuciÃ³n:*
[source,text,linenums]
----
   Compiling hola_mundo v0.1.0 (/ruta/hola_mundo)  // <1>
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.42s  // <2>
     Running `target/debug/hola_mundo`  // <3>
Hello, world!  // <4>
----
<1> Cargo compila el proyecto (solo la primera vez o si hay cambios)
<2> Perfil de compilaciÃ³n: `dev` (desarrollo, sin optimizaciones)
<3> Ruta del ejecutable que se estÃ¡ ejecutando
<4> Output de tu programa

[TIP]
====
Si no modificaste el cÃ³digo, la segunda ejecuciÃ³n serÃ¡ instantÃ¡nea:

[source,text]
----
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/hola_mundo`
Hello, world!
----

Cargo solo recompila lo que cambiÃ³ (*compilaciÃ³n incremental*).
====

==== Solo compilar (sin ejecutar)

[source,bash]
----
cargo build
----

El binario se genera en `target/debug/`:

[cols="1,2", options="header"]
|===
|Sistema
|UbicaciÃ³n del ejecutable

|Windows
|`target\debug\hola_mundo.exe`

|Linux/macOS
|`target/debug/hola_mundo`
|===

Puedes ejecutarlo manualmente:

[source,bash]
----
# Linux/macOS
./target/debug/hola_mundo

# Windows
.\target\debug\hola_mundo.exe
----

=== OpciÃ³n 2: Con rustc (Solo para aprendizaje)

Para pruebas rÃ¡pidas o aprendizaje, puedes compilar directamente con `rustc`:

[source,bash]
----
# Compilar main.rs
rustc src/main.rs

# Ejecutar el binario generado
# Windows
.\main.exe

# Linux/macOS
./main
----

WARNING: Compilar con `rustc` directamente es Ãºtil para aprender, pero para proyectos reales *siempre usa Cargo*. Cargo gestiona dependencias, optimizaciones y estructura del proyecto automÃ¡ticamente.

'''

== ğŸ› ï¸ Comandos Esenciales de Desarrollo

=== VerificaciÃ³n rÃ¡pida: `cargo check`

El comando mÃ¡s rÃ¡pido durante el desarrollo:

[source,bash]
----
cargo check
----

.ComparaciÃ³n
[cols="1,1", options="header"]
|===
|`cargo build`
|`cargo check`

|Compila completamente
|Solo verifica errores

|Genera ejecutable
|No genera ejecutable

|~3-10 segundos
|~0.5-2 segundos

|Uso: antes de ejecutar
|Uso: mientras editas
|===

.*Â¿CuÃ¡ndo usar `cargo check`?*

* icon:check[] Mientras escribes cÃ³digo
* icon:check[] Para verificar sintaxis rÃ¡pidamente
* icon:check[] Si olvidaste un `;` o cerraste mal una llave `{ }`
* icon:check[] Antes de hacer commit

.*Ejemplo de error detectado:*
[source,rust,linenums,highlight=2]
----
fn main() {
    let x = 5  // <1>
    println!("{}", x);
}
----
<1> Â¡Falta el punto y coma!

.Mensaje de error
[source,text]
----
error: expected `;`, found `println`
 --> src/main.rs:3:5
  |
2 |     let x = 5
  |              ^ help: add `;` here
3 |     println!("{}", x);
  |     ^^^^^^^ expected `;`
----

=== Ejecutar con argumentos

[source,bash]
----
# Pasar argumentos al programa
cargo run -- arg1 arg2 arg3

# Ejemplo prÃ¡ctico
cargo run -- --help
----

=== Limpiar archivos compilados

[source,bash]
----
cargo clean
----

.*Â¿CuÃ¡ndo usar?*

* Liberar espacio en disco (la carpeta `target/` puede ocupar cientos de MB)
* Forzar una recompilaciÃ³n completa desde cero
* Antes de comprimir/compartir el proyecto

NOTE: DespuÃ©s de `cargo clean`, la prÃ³xima compilaciÃ³n serÃ¡ mÃ¡s lenta porque Cargo debe recompilar todo desde cero.

'''

== ğŸš€ CompilaciÃ³n para ProducciÃ³n

=== Modo Release

Cuando necesites un binario optimizado para distribuir:

[source,bash]
----
cargo build --release
----

El ejecutable optimizado se genera en `target/release/`.

.Diferencias entre perfiles
[cols="1,2,2", options="header"]
|===
|
|Debug (`cargo build`)
|Release (`cargo build --release`)

|*OptimizaciÃ³n*
|Ninguna (mÃ¡s rÃ¡pido de compilar)
|MÃ¡xima (O3, LTO opcional)

|*Velocidad de ejecuciÃ³n*
|10-100x mÃ¡s lenta
|MÃ¡ximo rendimiento

|*TamaÃ±o del binario*
|MÃ¡s grande (incluye debug info)
|MÃ¡s pequeÃ±o (stripped)

|*Tiempo de compilaciÃ³n*
|RÃ¡pido (~3-10s)
|Lento (~10-60s)

|*Debugging*
|Completo (con sÃ­mbolos)
|Limitado

|*UbicaciÃ³n*
|`target/debug/`
|`target/release/`

|*CuÃ¡ndo usar*
|Desarrollo diario
|ProducciÃ³n, distribuciÃ³n, benchmarks
|===

IMPORTANT: Siempre usa `--release` para medir el rendimiento real de tu cÃ³digo. El modo debug puede ser Ã³rdenes de magnitud mÃ¡s lento.

.*Ejemplo de diferencia de rendimiento:*
[source,text]
----
Debug:   ProcesÃ³ 1M elementos en 850ms
Release: ProcesÃ³ 1M elementos en 12ms  (70x mÃ¡s rÃ¡pido!)
----

=== Ejecutar en modo release

[source,bash]
----
cargo run --release
----

'''

== ğŸ“¦ GestiÃ³n de Dependencias

=== AÃ±adir una dependencia

Existen dos formas:

==== OpciÃ³n 1: Editar `Cargo.toml` manualmente

.Ejemplo: AÃ±adir la librerÃ­a `rand`
[source,toml,linenums,highlight=7-8]
----
[package]
name = "hola_mundo"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8"  # <1>
serde = { version = "1.0", features = ["derive"] }  # <2>
----
<1> LibrerÃ­a para generar nÃºmeros aleatorios
<2> LibrerÃ­a de serializaciÃ³n con caracterÃ­sticas adicionales

==== OpciÃ³n 2: Usar `cargo add` (Rust 1.62+)

[source,bash]
----
# AÃ±adir dependencia
cargo add rand

# AÃ±adir con features especÃ­ficas
cargo add serde --features derive
----

[TIP]
====
`cargo add` es mÃ¡s conveniente y actualiza automÃ¡ticamente `Cargo.toml` con la Ãºltima versiÃ³n compatible.
====

=== Versionado SemÃ¡ntico

Cargo usa https://semver.org/[Semantic Versioning]:

[source,toml]
----
[dependencies]
# Compatible (recomendado) - permite 1.0.x, 1.1.x, etc.
serde = "1.0"  # <1>

# Exacta
serde = "=1.0.195"

# Rango
serde = ">=1.0, <2.0"

# Ãšltima versiÃ³n (NO recomendado en producciÃ³n)
serde = "*"
----
<1> Equivalente a `"^1.0"` (permite actualizaciones compatibles, pero NO 2.0)

=== Tipos de dependencias

==== Dependencias normales

[source,toml]
----
[dependencies]
tokio = { version = "1.35", features = ["full"] }
----

==== Dependencias de desarrollo

Para testing y herramientas de desarrollo:

[source,toml]
----
[dev-dependencies]
criterion = "0.5"  # Para benchmarks
proptest = "1.4"   # Para property testing
----

Estas *NO* se incluyen en la compilaciÃ³n final del binario.

==== Dependencias desde Git

[source,toml]
----
[dependencies]
mi_lib = { git = "https://github.com/usuario/repo" }
----

==== Dependencias locales

[source,toml]
----
[dependencies]
mi_lib = { path = "../mi_lib" }
----

=== Actualizar dependencias

[source,bash]
----
# Actualizar segÃºn Cargo.toml (respetando semver)
cargo update

# Actualizar una dependencia especÃ­fica
cargo update -p serde

# Ver versiones disponibles
cargo search serde
----

'''

== ğŸ”§ Comandos Avanzados

=== Testing

[source,bash]
----
# Ejecutar todos los tests
cargo test

# Ejecutar tests especÃ­ficos
cargo test mi_test

# Mostrar output de println! en tests
cargo test -- --nocapture
----

=== DocumentaciÃ³n

[source,bash]
----
# Generar y abrir documentaciÃ³n
cargo doc --open

# Incluir documentaciÃ³n privada
cargo doc --open --document-private-items
----

=== Benchmarks

[source,bash]
----
cargo bench
----

=== Publicar en crates.io

[source,bash]
----
# Verificar antes de publicar
cargo publish --dry-run

# Publicar
cargo publish
----

'''

== ğŸ“ Estructura Completa de un Proyecto

----
mi_proyecto/
â”œâ”€â”€ Cargo.toml           # ConfiguraciÃ³n del proyecto
â”œâ”€â”€ Cargo.lock           # Versiones exactas (Â¡no editar manualmente!)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs          # Punto de entrada (binario)
â”‚   â”œâ”€â”€ lib.rs           # Punto de entrada (biblioteca)
â”‚   â””â”€â”€ bin/             # MÃºltiples binarios
â”‚       â””â”€â”€ otro.rs
â”œâ”€â”€ tests/               # Tests de integraciÃ³n
â”‚   â””â”€â”€ integration_test.rs
â”œâ”€â”€ benches/             # Benchmarks
â”‚   â””â”€â”€ my_benchmark.rs
â”œâ”€â”€ examples/            # Ejemplos de uso
â”‚   â””â”€â”€ ejemplo.rs
â””â”€â”€ target/              # Archivos compilados (ignorar en Git)
----

=== Cargo.lock

[horizontal]
Binarios:: âœ… Commitear al repositorio
Bibliotecas:: âŒ AÃ±adir al `.gitignore`

Esto garantiza builds reproducibles en aplicaciones.

'''

== ğŸ’¡ Tips y Mejores PrÃ¡cticas

=== 1. Alias personalizados

Crea `~/.cargo/config.toml`:

[source,toml]
----
[alias]
b = "build"
r = "run"
t = "test"
c = "check"
----

Ahora: `cargo c` en lugar de `cargo check`

=== 2. Perfiles de compilaciÃ³n personalizados

En `Cargo.toml`:

[source,toml]
----
[profile.dev]
opt-level = 0  # Sin optimizaciÃ³n (rÃ¡pido de compilar)

[profile.release]
opt-level = 3     # MÃ¡xima optimizaciÃ³n
lto = true        # Link-Time Optimization
codegen-units = 1 # Mejor optimizaciÃ³n, compilaciÃ³n mÃ¡s lenta
----

=== 3. CaracterÃ­sticas opcionales

[source,toml]
----
[features]
default = ["feature1"]
feature1 = []
feature2 = ["dep:serde"]

[dependencies]
serde = { version = "1.0", optional = true }
----

Compilar con feature:
[source,bash]
----
cargo build --features "feature2"
----

'''

== ğŸ¯ Flujo de Trabajo Recomendado

.Desarrollo dÃ­a a dÃ­a
[source,bash,linenums]
----
# 1. Crear proyecto
cargo new mi_app && cd mi_app

# 2. Editar cÃ³digo en src/main.rs
# (usar tu editor favorito)

# 3. Verificar errores rÃ¡pidamente
cargo check

# 4. Compilar y ejecutar
cargo run

# 5. Repetir pasos 2-4 hasta terminar

# 6. Tests (si los hay)
cargo test

# 7. Compilar versiÃ³n optimizada final
cargo build --release
----

'''

== ğŸ“Š Cheat Sheet de Comandos

[cols="2,3", options="header"]
|===
|Comando
|DescripciÃ³n

|`cargo new <nombre>`
|Crear proyecto nuevo

|`cargo build`
|Compilar en modo debug

|`cargo build --release`
|Compilar optimizado para producciÃ³n

|`cargo run`
|Compilar y ejecutar

|`cargo run --release`
|Ejecutar versiÃ³n optimizada

|`cargo check`
|Verificar errores sin compilar

|`cargo test`
|Ejecutar tests

|`cargo clean`
|Limpiar archivos compilados

|`cargo update`
|Actualizar dependencias

|`cargo doc --open`
|Generar y abrir documentaciÃ³n

|`cargo add <crate>`
|AÃ±adir dependencia
|===

TIP: Ejecuta `cargo --help` para ver todos los comandos, o `cargo <comando> --help` para ayuda especÃ­fica.

'''

== ğŸ”— Recursos Adicionales

* ğŸ“– https://doc.rust-lang.org/cargo/[DocumentaciÃ³n oficial de Cargo]
* ğŸ“¦ https://crates.io[Crates.io] - Repositorio de paquetes
* ğŸ” https://docs.rs[Docs.rs] - DocumentaciÃ³n de crates
* ğŸ“š https://doc.rust-lang.org/cargo/index.html[Cargo Book]

'''

[quote, Rust Community]
____
ğŸ¦€ *Recuerda*: Cargo es tu mejor amigo en Rust.

Aprende a dominarlo y tu productividad se multiplicarÃ¡. Cargo serÃ¡ tu compaÃ±ero constante en este viaje de aprendizaje.
____

*Siguiente tema*: Variables y Mutabilidad (`let` y `let mut`) â†’
