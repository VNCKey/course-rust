= üìù Variables y Mutabilidad en Rust
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: rouge
:rouge-style: monokai
:experimental:

[abstract]
.Sobre este m√≥dulo
====
En este m√≥dulo aprender√°s:

* Variables inmutables con `let`
* Variables mutables con `let mut`
* Shadowing (sombreado de variables)
* Constantes con `const`
* Variables est√°ticas con `static`
* Scope (alcance de las variables)
* Expresiones vs Statements
* Documentaci√≥n de c√≥digo con cargo doc

*Tiempo estimado*: 45-60 minutos
====

'''

== Variables con `let`

En Rust, las variables son **inmutables por defecto**. Esto significa que una vez que asignas un valor, no puedes cambiarlo.

[IMPORTANT]
====
La inmutabilidad por defecto es una caracter√≠stica clave de Rust que previene bugs y hace el c√≥digo m√°s seguro y predecible.
====

=== Ejemplo B√°sico

[source,rust,linenums]
----
fn main() {
    // Las variables son inmutables por defecto
    let edad = 25;  // <1>

    // Formas de imprimir
    println!("Mi edad es {}", edad);  // <2>
    println!("Mi edad es {edad}");    // <3>
}
----
<1> Variable inmutable `edad` con valor 25
<2> Formato tradicional con `{}`
<3> Formato interpolado (Rust 1.58+)

.Output
[source,text]
----
Mi edad es 25
Mi edad es 25
----

=== Intentar Mutar una Variable Inmutable

[source,rust,linenums,highlight=5]
----
fn main() {
    let edad = 25;

    // ‚ùå Esto causar√° un error de compilaci√≥n
    edad = 26;  // <1>

    println!("Mi edad es {edad}");
}
----
<1> Error: cannot assign twice to immutable variable

.Error de compilaci√≥n
[source,text]
----
error[E0384]: cannot assign twice to immutable variable `edad`
 --> src/main.rs:5:5
  |
2 |     let edad = 25;
  |         ----
  |         |
  |         first assignment to `edad`
  |         help: consider making this binding mutable: `mut edad`
5 |     edad = 26;
  |     ^^^^^^^^^ cannot assign twice to immutable variable
----

NOTE: Observa c√≥mo el compilador te sugiere la soluci√≥n: a√±adir `mut`.

'''

== Variables Mutables con `let mut`

Si necesitas cambiar el valor de una variable, debes declararla expl√≠citamente como **mutable** usando `let mut`.

=== Ejemplo B√°sico de Mutabilidad

[source,rust,linenums]
----
fn main() {
    // Variable mutable
    let mut carro = "Toyota";  // <1>

    println!("Mi carro es {}", carro);

    // ‚úÖ Podemos cambiar el valor
    carro = "Honda";  // <2>

    println!("Mi nuevo carro es {}", carro);
}
----
<1> `mut` permite que la variable sea mutable
<2> Reasignaci√≥n v√°lida porque `carro` es mutable

.Output
[source,text]
----
Mi carro es Toyota
Mi nuevo carro es Honda
----

=== Mutabilidad con Tipos Num√©ricos

[source,rust,linenums]
----
fn main() {
    let mut contador = 0;

    println!("Contador inicial: {contador}");

    contador += 1;  // <1>
    println!("Despu√©s de incrementar: {contador}");

    contador *= 2;  // <2>
    println!("Despu√©s de duplicar: {contador}");
}
----
<1> Incrementa el contador en 1
<2> Multiplica el contador por 2

.Output
[source,text]
----
Contador inicial: 0
Despu√©s de incrementar: 1
Despu√©s de duplicar: 2
----

[TIP]
====
Usa `mut` solo cuando realmente necesites mutar la variable. La inmutabilidad hace el c√≥digo m√°s f√°cil de razonar.
====

'''

== Shadowing (Sombreado de Variables)

El **shadowing** permite declarar una nueva variable con el mismo nombre que una anterior. La nueva variable "sombrea" a la anterior.

=== Shadowing B√°sico

[source,rust,linenums]
----
fn main() {
    let edad = 25;  // <1>

    println!("Mi edad es {}", edad);

    let edad = 35;  // <2>

    println!("Mi edad sombreada es {}", edad);
}
----
<1> Primera declaraci√≥n de `edad`
<2> Segunda declaraci√≥n que sombrea a la primera

.Output
[source,text]
----
Mi edad es 25
Mi edad sombreada es 35
----

=== Diferencia: Shadowing vs Mutabilidad

[cols="1,2,2", options="header"]
|===
|
|Shadowing (`let`)
|Mutabilidad (`mut`)

|*Sintaxis*
|`let x = ...; let x = ...;`
|`let mut x = ...; x = ...;`

|*Cambio de tipo*
|‚úÖ Permitido
|‚ùå No permitido

|*Crea nueva variable*
|‚úÖ S√≠
|‚ùå No (misma variable)

|*Cu√°ndo usar*
|Transformaciones de datos
|Valores que cambian en el tiempo
|===

=== Shadowing con Cambio de Tipo

[source,rust,linenums]
----
fn main() {
    let espacios = "   ";  // <1>
    println!("Tipo: String slice, valor: '{}'", espacios);

    let espacios = espacios.len();  // <2>
    println!("Tipo: n√∫mero, valor: {}", espacios);
}
----
<1> `espacios` es un `&str` (string slice)
<2> `espacios` ahora es un `usize` (n√∫mero)

.Output
[source,text]
----
Tipo: String slice, valor: '   '
Tipo: n√∫mero, valor: 3
----

[NOTE]
====
Con `mut`, este c√≥digo no compilar√≠a porque no puedes cambiar el tipo de una variable mutable:

[source,rust]
----
let mut espacios = "   ";
espacios = espacios.len();  // ‚ùå Error: tipos incompatibles
----
====

=== Shadowing en Diferentes Scopes

[source,rust,linenums]
----
fn main() {
    let x = 5;  // <1>
    println!("Outer x: {x}");

    {
        let x = x * 2;  // <2>
        println!("Inner x: {x}");
    }

    println!("Outer x despu√©s del bloque: {x}");  // <3>
}
----
<1> `x` en el scope externo vale 5
<2> `x` en el scope interno sombrea al externo y vale 10
<3> El `x` externo sigue siendo 5

.Output
[source,text]
----
Outer x: 5
Inner x: 10
Outer x despu√©s del bloque: 5
----

'''

== Scope (Alcance de Variables)

El **scope** determina d√≥nde una variable es v√°lida en tu c√≥digo. En Rust, el scope est√° definido por llaves `{ }`.

=== Scope B√°sico

[source,rust,linenums]
----
fn main() {
    let x = 10;  // <1>

    {
        let y = 20;  // <2>
        println!("x = {}, y = {}", x, y);  // <3>
    }  // <4>

    println!("x = {}", x);  // <5>
    // println!("y = {}", y);  // ‚ùå Error: y no existe aqu√≠
}
----
<1> `x` declarada en el scope externo
<2> `y` declarada en el scope interno
<3> Ambas variables son accesibles dentro del bloque interno
<4> `y` se destruye al salir del bloque
<5> Solo `x` es accesible aqu√≠

.Output
[source,text]
----
x = 10, y = 20
x = 10
----

=== Scope y Ownership

[source,rust,linenums]
----
fn main() {
    let mensaje = String::from("Hola");  // <1>

    {
        let saludo = mensaje;  // <2>
        println!("Dentro: {saludo}");
    }  // <3>

    // println!("Fuera: {mensaje}");  // ‚ùå Error: valor movido
}
----
<1> `mensaje` es due√±o del String
<2> Ownership se mueve a `saludo`
<3> `saludo` se destruye aqu√≠, liberando la memoria

[IMPORTANT]
====
Este ejemplo muestra **ownership**: cuando `mensaje` se mueve a `saludo`, `mensaje` ya no es v√°lido.
====

=== Scope Anidado

[source,rust,linenums]
----
fn main() {
    let a = 1;

    {
        let b = 2;

        {
            let c = 3;
            println!("a={}, b={}, c={}", a, b, c);  // <1>
        }

        println!("a={}, b={}", a, b);  // <2>
        // println!("c={}", c);  // ‚ùå Error
    }

    println!("a={}", a);  // <3>
}
----
<1> Todas las variables accesibles en el scope m√°s interno
<2> Solo `a` y `b` accesibles aqu√≠
<3> Solo `a` accesible en el scope externo

'''

== Constantes con `const`

Las **constantes** son valores que nunca cambian y deben tener un tipo expl√≠cito.

=== Declaraci√≥n de Constantes

[source,rust,linenums]
----
// Constantes se declaran fuera de funciones
const MAX_PUNTOS: u32 = 100_000;  // <1>
const PI: f64 = 3.14159265359;    // <2>
const APP_VERSION: &str = "1.0.0";

fn main() {
    println!("M√°ximo de puntos: {}", MAX_PUNTOS);
    println!("Valor de PI: {}", PI);
    println!("Versi√≥n: {}", APP_VERSION);
}
----
<1> Las constantes SIEMPRE usan `SCREAMING_SNAKE_CASE`
<2> El tipo debe ser expl√≠cito (`u32`, `f64`, etc.)

.Output
[source,text]
----
M√°ximo de puntos: 100000
Valor de PI: 3.14159265359
Versi√≥n: 1.0.0
----

=== Reglas de las Constantes

[cols="1,2", options="header"]
|===
|Regla
|Descripci√≥n

|*Tipo expl√≠cito*
|Siempre debes anotar el tipo

|*Expresiones constantes*
|Solo pueden ser valores calculables en compile-time

|*Inmutables*
|NUNCA pueden ser mutables (no existe `mut const`)

|*Scope global*
|Pueden declararse fuera de funciones

|*Naming*
|Siempre en MAY√öSCULAS con guiones bajos
|===

[source,rust,linenums]
----
const SEGUNDOS_EN_HORA: u32 = 60 * 60;  // ‚úÖ OK: expresi√≥n constante

fn main() {
    const LOCAL: i32 = 42;  // ‚úÖ OK: constante local
    println!("Segundos en hora: {}", SEGUNDOS_EN_HORA);
    println!("Constante local: {}", LOCAL);
}
----

=== Constantes vs Variables Inmutables

[cols="1,2,2", options="header"]
|===
|
|`const`
|`let` (inmutable)

|*Cambio*
|Nunca
|Nunca (pero puede usar shadowing)

|*Tipo*
|Siempre expl√≠cito
|Puede inferirse

|*Scope*
|Global o local
|Local

|*Valor*
|Solo compile-time
|Cualquier valor (runtime)

|*Inlining*
|S√≠, se inlinea
|No necesariamente
|===

'''

== Variables Est√°ticas con `static`

Las **variables est√°ticas** tienen una ubicaci√≥n fija en memoria y viven durante toda la ejecuci√≥n del programa.

=== Declaraci√≥n de Variables Est√°ticas

[source,rust,linenums]
----
/// Nombre de la aplicaci√≥n
pub static APP_NAME: &str = "MiApp";  // <1>

/// Versi√≥n del protocolo
static PROTOCOLO_VERSION: u8 = 2;

fn main() {
    // Tiene direcci√≥n √∫nica en memoria
    println!("Static: {}", APP_NAME);  // <2>
    println!("Protocolo v{}", PROTOCOLO_VERSION);
}
----
<1> `pub` hace la variable accesible desde otros m√≥dulos
<2> Todos los usos comparten la misma ubicaci√≥n de memoria

.Output
[source,text]
----
Static: MiApp
Protocolo v2
----

=== Diferencias: `const` vs `static`

[cols="1,2,2", options="header"]
|===
|
|`const`
|`static`

|*Memoria*
|Se inlinea (copia en cada uso)
|Direcci√≥n fija en memoria

|*Mutabilidad*
|Nunca
|Posible con `unsafe`

|*Lifetime*
|No aplica
|`'static`

|*Cu√°ndo usar*
|Valores inmutables simples
|Valores compartidos globales
|===

=== Ejemplo Comparativo

[source,rust,linenums]
----
const VALOR_CONSTANTE: &str = "Texto constante";  // <1>
static VALOR_ESTATICO: &str = "Texto est√°tico";   // <2>

fn main() {
    // const: cada uso es una copia del valor literal
    println!("Constante: {}", VALOR_CONSTANTE);

    // static: tiene direcci√≥n √∫nica en memoria
    println!("Static: {}", VALOR_ESTATICO);

    // Puedes obtener la direcci√≥n de un static
    println!("Direcci√≥n de static: {:p}", &VALOR_ESTATICO as *const _);
}
----
<1> Se inlinea: cada uso es una copia
<2> Ubicaci√≥n √∫nica en memoria compartida

'''

== Expresiones vs Statements

En Rust, es crucial entender la diferencia entre **expresiones** y **statements**.

=== ¬øQu√© es un Statement?

Un **statement** es una instrucci√≥n que realiza una acci√≥n pero **NO retorna un valor**.

[source,rust,linenums]
----
fn main() {
    let x = 5;           // <1>
    let y = {            // <2>
        let z = 3;       // statement
        z + 1            // <3>
    };

    println!("x = {}, y = {}", x, y);
}
----
<1> Statement: declaraci√≥n de variable
<2> `y` recibe el valor de la expresi√≥n del bloque
<3> Expresi√≥n: retorna `z + 1` (sin `;`)

.Output
[source,text]
----
x = 5, y = 4
----

=== ¬øQu√© es una Expresi√≥n?

Una **expresi√≥n** eval√∫a a un valor y puede ser usada donde se espera un valor.

[source,rust,linenums]
----
fn main() {
    // Todo lo siguiente son expresiones
    let a = 5;              // 5 es una expresi√≥n
    let b = a + 1;          // a + 1 es una expresi√≥n
    let c = if a > 3 { 10 } else { 20 };  // <1>

    println!("a={}, b={}, c={}", a, b, c);
}
----
<1> `if` es una expresi√≥n que retorna un valor

=== Bloques como Expresiones

[source,rust,linenums]
----
fn main() {
    let resultado = {
        let x = 3;
        x * x  // <1>
    };

    println!("El resultado es: {resultado}");

    let con_semicolon = {
        let y = 5;
        y * 2;  // <2>
    };

    println!("Con semicolon: {:?}", con_semicolon);  // <3>
}
----
<1> Sin `;` ‚Üí retorna `9`
<2> Con `;` ‚Üí es un statement
<3> `con_semicolon` es `()` (unit type)

.Output
[source,text]
----
El resultado es: 9
Con semicolon: ()
----

[IMPORTANT]
====
*Regla de oro*:

* Sin `;` al final ‚Üí Expresi√≥n (retorna valor)
* Con `;` al final ‚Üí Statement (no retorna valor, retorna `()`)
====

=== Funciones como Expresiones

[source,rust,linenums]
----
/// Calcula el cuadrado de un n√∫mero
fn cuadrado(n: i32) -> i32 {
    n * n  // <1>
}

/// Retorna el mayor de dos n√∫meros
fn maximo(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }  // <2>
}

fn main() {
    let x = cuadrado(5);
    let y = maximo(10, 20);

    println!("Cuadrado de 5: {}", x);
    println!("M√°ximo(10, 20): {}", y);
}
----
<1> Expresi√≥n de retorno (sin `return` ni `;`)
<2> `if` como expresi√≥n que retorna un valor

'''

== Anotaciones de Tipo

Rust infiere tipos autom√°ticamente, pero puedes (y a veces debes) anotarlos expl√≠citamente.

=== Inferencia de Tipos

[source,rust,linenums]
----
fn main() {
    let x = 5;           // i32 inferido
    let y = 2.5;         // f64 inferido
    let nombre = "Ana";  // &str inferido

    println!("x: {}, y: {}, nombre: {}", x, y, nombre);
}
----

=== Anotaciones Expl√≠citas

[source,rust,linenums]
----
fn main() {
    let edad: u8 = 25;              // <1>
    let precio: f32 = 19.99;        // <2>
    let activo: bool = true;        // <3>
    let letra: char = 'A';          // <4>

    println!("Edad: {}, Precio: {}, Activo: {}, Letra: {}",
             edad, precio, activo, letra);
}
----
<1> `u8`: entero sin signo de 8 bits (0-255)
<2> `f32`: flotante de 32 bits
<3> `bool`: booleano
<4> `char`: caracter Unicode (4 bytes)

=== Cu√°ndo Son Necesarias las Anotaciones

[source,rust,linenums]
----
fn main() {
    // ‚ùå Error: no puede inferir el tipo
    // let numero = "42".parse().unwrap();

    // ‚úÖ Opci√≥n 1: Anotar la variable
    let numero: i32 = "42".parse().unwrap();

    // ‚úÖ Opci√≥n 2: Turbofish syntax
    let otro = "100".parse::<i32>().unwrap();

    println!("N√∫mero: {}, Otro: {}", numero, otro);
}
----

'''

== Documentaci√≥n con cargo doc

Rust tiene un sistema de documentaci√≥n integrado. Los **doc comments** se escriben con `///` o `//!`.

=== Doc Comments para Funciones

[source,rust,linenums]
----
/// Calcula el √°rea de un rect√°ngulo.
///
/// # Argumentos
///
/// * `ancho` - El ancho del rect√°ngulo
/// * `alto` - El alto del rect√°ngulo
///
/// # Ejemplos
///
/// ```
/// let area = area_rectangulo(5, 10);
/// assert_eq!(area, 50);
/// ```
///
/// # Panics
///
/// Esta funci√≥n no hace panic.
fn area_rectangulo(ancho: u32, alto: u32) -> u32 {
    ancho * alto
}

fn main() {
    let area = area_rectangulo(5, 10);
    println!("√Årea: {}", area);
}
----

=== Doc Comments para M√≥dulos

[source,rust,linenums]
----
//! Este m√≥dulo contiene funciones matem√°ticas b√°sicas.
//!
//! # Ejemplos
//!
//! ```
//! use mi_crate::suma;
//! assert_eq!(suma(2, 3), 5);
//! ```

/// Suma dos n√∫meros
pub fn suma(a: i32, b: i32) -> i32 {
    a + b
}

/// Resta dos n√∫meros
pub fn resta(a: i32, b: i32) -> i32 {
    a - b
}
----

=== Generar Documentaci√≥n

[source,bash]
----
# Generar y abrir la documentaci√≥n
cargo doc --open
----

Esto genera HTML interactivo con tu documentaci√≥n.

[TIP]
====
Escribe doc comments para:

* Funciones p√∫blicas
* Structs y enums
* M√≥dulos
* Comportamiento no obvio
====

'''

== Ejemplos Pr√°cticos Completos

=== Ejemplo 1: Convertidor de Temperatura

[source,rust,linenums]
----
/// Convierte grados Celsius a Fahrenheit
///
/// # Ejemplos
///
/// ```
/// let f = celsius_a_fahrenheit(0.0);
/// assert_eq!(f, 32.0);
/// ```
fn celsius_a_fahrenheit(celsius: f64) -> f64 {
    celsius * 1.8 + 32.0
}

fn main() {
    let temp_celsius = 25.0;
    let temp_fahrenheit = celsius_a_fahrenheit(temp_celsius);

    println!("{:.1}¬∞C = {:.1}¬∞F", temp_celsius, temp_fahrenheit);
}
----

=== Ejemplo 2: Calculadora de IMC

[source,rust,linenums]
----
/// Calcula el √çndice de Masa Corporal (IMC)
///
/// # Argumentos
///
/// * `peso_kg` - Peso en kilogramos
/// * `altura_m` - Altura en metros
fn calcular_imc(peso_kg: f64, altura_m: f64) -> f64 {
    peso_kg / (altura_m * altura_m)
}

fn main() {
    let peso = 70.0;
    let altura = 1.75;

    let imc = calcular_imc(peso, altura);

    println!("Peso: {}kg", peso);
    println!("Altura: {}m", altura);
    println!("IMC: {:.2}", imc);

    // Clasificaci√≥n usando expresi√≥n if
    let clasificacion = if imc < 18.5 {
        "Bajo peso"
    } else if imc < 25.0 {
        "Peso normal"
    } else if imc < 30.0 {
        "Sobrepeso"
    } else {
        "Obesidad"
    };

    println!("Clasificaci√≥n: {}", clasificacion);
}
----

=== Ejemplo 3: Contador con Estado

[source,rust,linenums]
----
/// Representa un contador con l√≠mite m√°ximo
static MAX_CONTADOR: i32 = 100;

fn main() {
    let mut contador = 0;

    println!("Contador inicial: {}", contador);

    // Incrementar en un loop
    for _ in 0..5 {
        contador += 1;

        if contador >= MAX_CONTADOR {
            println!("¬°L√≠mite alcanzado!");
            break;
        }

        println!("Contador: {}", contador);
    }

    // Shadowing para cambiar el tipo
    let contador = format!("Final: {}", contador);
    println!("{}", contador);
}
----

'''

== Resumen

[cols="1,2,2", options="header"]
|===
|Concepto
|Sintaxis
|Cu√°ndo Usar

|*Variable inmutable*
|`let x = 5;`
|Por defecto, siempre que no necesites mutar

|*Variable mutable*
|`let mut x = 5;`
|Cuando el valor cambia con el tiempo

|*Shadowing*
|`let x = ...; let x = ...;`
|Transformaciones o cambio de tipo

|*Constante*
|`const MAX: u32 = 100;`
|Valores conocidos en compile-time

|*Static*
|`static VAR: &str = "x";`
|Variables globales con direcci√≥n fija

|*Scope*
|`{ let x = ...; }`
|Limitar el alcance de variables
|===

'''

== Ejercicios Pr√°cticos

=== Ejercicio 1: Variables B√°sicas

Crea un programa que:

. Declare una variable inmutable `nombre` con tu nombre
. Declare una variable mutable `edad` con tu edad
. Incremente la edad en 1
. Use shadowing para convertir el nombre a may√∫sculas

=== Ejercicio 2: Scope

Crea un programa con 3 niveles de scope anidados y demuestra qu√© variables son accesibles en cada nivel.

=== Ejercicio 3: Expresiones

Escribe una funci√≥n que use un bloque de expresi√≥n para calcular el m√°ximo de tres n√∫meros.

'''

[quote, Rust Community]
____
ü¶Ä *Recuerda*:

La inmutabilidad por defecto es una de las caracter√≠sticas m√°s importantes de Rust. Te ayuda a escribir c√≥digo m√°s seguro y predecible.

Usa `mut` solo cuando realmente lo necesites.
____

*Siguiente tema*: Tipos de Datos (Escalares y Compuestos) ‚Üí
