=  Ruta de Aprendizaje Rust 2026
:subtitle: De Principiante a Experto
:source-highlighter: rouge
:rouge-style: monokai
:icons: font
:toc: left
:toclevels: 4
:toc-title: ndice de Contenido
:sectnums:
:experimental:

'''

[.text-center]
==  Niveles de Dominio

[cols="1,2,1,3", options="header"]
|===
|Nivel
|Descripci贸n
|M贸dulos
|Duraci贸n Estimada

| *Principiante*
|Sintaxis b谩sica, ownership, control de flujo
|0-6
|3-4 semanas

| *Intermedio*
|Gen茅ricos, errores, colecciones, iteradores
|7-12
|4-6 semanas

| *Avanzado*
|Traits avanzados, lifetimes, concurrencia, async
|13-17
|6-8 semanas

| *Experto*
|Macros, unsafe, FFI, testing, optimizaci贸n
|18-21
|4-6 semanas
|===

'''

= NIVEL PRINCIPIANTE 

== M贸dulo 0: Preparaci贸n del Entorno

.*Objetivos*: Configurar el entorno y familiarizarse con las herramientas

En este m贸dulo aprender谩s a:

* Instalar Rust y rustup
* Configurar toolchains (`stable`, `beta`, `nightly`)
* Actualizar tu entorno de desarrollo
* Gestionar versiones con rustup

=== Herramientas Esenciales

* *Cargo*: Gestor de proyectos y dependencias
* *rustc*: Compilador de Rust
* *rustfmt*: Formateador de c贸digo
* *Clippy*: Linter y sugerencias
* *rust-analyzer*: Language Server Protocol (LSP)

=== Configuraci贸n del Editor

Tutoriales para configurar tus editores de c贸digo favoritos:

* VS Code + rust-analyzer
* Zed con extensiones Rust
* Neovim + rust-tools.nvim
* IntelliJ IDEA + Rust plugin

=== Tu Primer Proyecto

Construir谩s tu primer proyecto y aprender谩s:

* Estructura de un proyecto Rust (`src/`, `Cargo.toml`, `target/`)
* Compilaci贸n: `cargo build`, `cargo run`
* Perfiles: `--debug` vs `--release`
* Verificaci贸n r谩pida: `cargo check`

'''

== M贸dulo 1: Sintaxis B谩sica y Tipos

.*Objetivos*: Dominar la sintaxis fundamental de Rust

=== Variables y Conceptos Elementales

* Variables inmutables: `let`
* Variables mutables: `let mut`
* Constantes: `const`
* Variables est谩ticas: `static`
* Shadowing (sombreado de variables)
* Scope (alcance de las variables)

=== Tipos de Datos

==== Escalares
* Enteros: `i32`, `u32`, `i64`, etc.
* Flotantes: `f32`, `f64`
* Booleanos: `bool`
* Caracteres: `char`

==== Compuestos
* Tuplas: `(i32, f64, char)`
* Arrays: `[i32; 5]`
* Slices: `&[T]`

=== Manejo de Texto

* `String` vs `&str`
* Conversi贸n entre tipos
* M茅todos comunes de String

=== Vector

* Creaci贸n: `vec![]`, `Vec::new()`
* M茅todos: `push`, `pop`, `len`
* Acceso: indexing vs `get()`
* Iteraci贸n sobre vectores

=== Conceptos de Memoria

* Stack vs Heap
* Cu谩ndo se usa cada uno

=== Bloques y Expresiones

* Todo es expresi贸n en Rust
* Bloques `{ }` retornan valores
* Diferencia entre expresi贸n y sentencia

=== Documentaci贸n

* Comentarios: `//` y `/* */`
* Doc comments: `///` y `//!`
* Generar documentaci贸n: `cargo doc --open`

=== Macros de Uso Com煤n

* `println!` y `print!`: Imprimir en consola
* `format!`: Formatear strings
* `dbg!`: Debugging r谩pido
* `todo!` y `unimplemented!`: Marcadores temporales
* `panic!`: Errores irrecuperables

'''

== M贸dulo 2: Ownership y Borrowing

.*Objetivos*: Entender el sistema de ownership (concepto pilar de Rust)

=== Conceptos de Memoria

* Stack vs Heap (profundizaci贸n)
* Gesti贸n de memoria sin garbage collector
* Move semantics
* RAII (Resource Acquisition Is Initialization)

=== Reglas de Ownership

* Cada valor tiene un 煤nico due帽o
* Solo puede haber un due帽o a la vez
* Cuando el due帽o sale de scope, el valor se destruye

=== Borrowing (Pr茅stamo)

* Referencias inmutables: `&T`
* Referencias mutables: `&mut T`
* Reglas del borrow checker:
** M煤ltiples `&T` O una `&mut T`
** No ambos al mismo tiempo

=== Lifetimes B谩sicos

* Lifetimes impl铆citos
* Cu谩ndo Rust infiere lifetimes autom谩ticamente

IMPORTANT: Ownership es el concepto MS IMPORTANTE de Rust. Dedica tiempo a entenderlo bien.

'''

== M贸dulo 3: Control de Flujo

.*Objetivos*: Dominar estructuras de control en Rust

=== Condicionales

* `if`, `else if`, `else`
* `if let` para pattern matching simplificado
* Expresiones condicionales (if como expresi贸n)

=== Bucles

* `loop`: Bucle infinito
* `while`: Bucle condicional
* `for`: Iteraci贸n sobre colecciones
* `break` y `continue`
* Labels en bucles
* Retornar valores desde bucles

=== Pattern Matching

* `match`: Pattern matching exhaustivo
* Wildcards: `_`
* Match guards
* Destructuring en match

'''

== M贸dulo 4: Funciones

.*Objetivos*: Crear y usar funciones en Rust

=== Definici贸n de Funciones

* Declaraci贸n y sintaxis
* Par谩metros y tipos
* Valores de retorno
* Retorno impl铆cito (煤ltima expresi贸n)
* Funciones divergentes: `-> !`

=== Closures (Clausuras)

* Sintaxis: `|param| body`
* Captura de variables del entorno
* Traits: `Fn`, `FnMut`, `FnOnce`
* Move closures: `move ||`

=== Funciones Asociadas

* M茅todos est谩ticos
* Constructores comunes

'''

== M贸dulo 5: Estructuras de Datos

.*Objetivos*: Modelar datos con structs y enums

=== Structs

* Classic structs: `struct Point { x: i32, y: i32 }`
* Tuple structs: `struct Color(u8, u8, u8);`
* Unit structs: `struct Marker;`
* Field init shorthand
* Struct update syntax

=== M茅todos e Implementaciones

* Bloques `impl`
* M茅todos: `&self`, `&mut self`, `self`
* Funciones asociadas (sin `self`)

=== Enumeraciones

* Definici贸n de enums
* Variantes con datos
* Enums complejos
* M茅todos en enums


'''

== M贸dulo 6: Traits B谩sicos

.*Objetivos*: Entender y usar traits fundamentales

=== Traits Derivables

* `Debug`: Formato `{:?}` y `{:#?}`
* `Clone`: Copia expl铆cita
* `Copy`: Copia impl铆cita
* `PartialEq` y `Eq`: Comparaci贸n
* `Default`: Valor por defecto

=== Derivar Traits

* Sintaxis: `#[derive(Debug, Clone, PartialEq)]`
* Cu谩ndo derivar vs implementar manualmente

=== Otros Traits Importantes

* `Display`: Formato `{}`
* `Drop`: Destructor autom谩tico

'''

== M贸dulo 7: Modularidad y Organizaci贸n

.*Objetivos*: Estructurar proyectos grandes

=== Sistema de M贸dulos

* Declaraci贸n: `mod module_name`
* Jerarqu铆a de m贸dulos
* `src/lib.rs` vs `src/main.rs`
* Archivos y directorios como m贸dulos

=== Visibilidad

* Privado por defecto
* `pub`: p煤blico
* `pub(crate)`: visible en el crate
* `pub(super)`: visible en el m贸dulo padre

=== Uso e Importaci贸n

* `use` statement
* Re-exportaci贸n: `pub use`
* Glob imports: `use module::*;`
* Alias: `use std::io::Result as IoResult;`

=== Paths

* Paths absolutos: `crate::`
* Paths relativos: `self::`, `super::`

=== Workspaces y Crates

* M煤ltiples crates en un proyecto
* `Cargo.toml` del workspace
* Dependencias compartidas

'''

= NIVEL INTERMEDIO 

== M贸dulo 8: Gen茅ricos

.*Objetivos*: Escribir c贸digo reutilizable con gen茅ricos

=== Funciones Gen茅ricas

* Sintaxis: `fn foo<T>(x: T)`
* M煤ltiples par谩metros de tipo
* Trait bounds: `where T: Display`

=== Structs Gen茅ricas

* Definici贸n: `struct Point<T> { x: T, y: T }`
* Implementaciones gen茅ricas
* Restricciones de tipo

=== Enums Gen茅ricos

* `Option<T>`, `Result<T, E>` (profundizaci贸n)
* Crear tus propios enums gen茅ricos

=== Lifetimes con Gen茅ricos

* Combinar lifetimes y gen茅ricos
* Sintaxis: `fn foo<'a, T>(x: &'a T)`

'''

== M贸dulo 9: Gesti贸n de Errores

.*Objetivos*: Manejar errores de forma robusta

=== Errores Recuperables

* `Option<T>`: `Some(T)` y `None`
* `Result<T, E>`: `Ok(T)` y `Err(E)`
* Operador `?` para propagaci贸n

=== Errores Irrecuperables

* `panic!` y cu谩ndo usarlo
* `unwrap` y `expect`
* Backtrace: `RUST_BACKTRACE=1`

=== Custom Error Types

* Crear tipos de error propios
* Implementar `std::error::Error`
* Enums como errores

=== Librer铆as de Errores

* *thiserror*: Derive macros para errors
* *anyhow*: Manejo simplificado de errores
* Cu谩ndo usar cada una

'''

== M贸dulo 10: Colecciones Avanzadas

.*Objetivos*: Trabajar con estructuras de datos complejas

=== HashMap<K, V>

* Creaci贸n e inserci贸n
* Acceso: `get()`, `[]`, `entry()`
* Iteraci贸n sobre keys/values/entries
* Actualizaci贸n de valores

=== HashSet<T>

* Operaciones de conjuntos
* Uni贸n, intersecci贸n, diferencia
* Membership testing

=== String y &str (Profundizaci贸n)

* Encodings: UTF-8
* Indexaci贸n y por qu茅 falla
* Slicing seguro
* M茅todos de transformaci贸n

=== Otras Colecciones

* `VecDeque<T>`: Double-ended queue
* `LinkedList<T>`: Lista enlazada
* `BTreeMap` y `BTreeSet`: Ordenados
* `BinaryHeap<T>`: Priority queue

'''

== M贸dulo 11: Type Aliases y Newtypes

.*Objetivos*: Crear tipos personalizados

=== Type Aliases

* Sintaxis: `type Kilometers = i32;`
* Cu谩ndo usarlos
* Type aliases para tipos complejos

=== Newtype Pattern

* Wrapper types: `struct UserId(u64);`
* Beneficios del newtype pattern
* Type safety adicional

=== Phantom Types

* `PhantomData<T>`
* Tipos fantasma para seguridad de tipos

'''

== M贸dulo 12: Iteradores

.*Objetivos*: Dominar el procesamiento de secuencias

=== Trait Iterator

* Implementar `Iterator`
* M茅todo `next()`
* `IntoIterator`

=== Adaptadores

* `map`: Transformar elementos
* `filter`: Filtrar elementos
* `take`, `skip`: Limitar iteraci贸n
* `enumerate`: Obtener 铆ndices
* `zip`: Combinar iteradores

=== Consumidores

* `collect`: Construir colecciones
* `sum`, `product`: Agregar valores
* `fold`: Reducci贸n personalizada
* `for_each`: Efectos secundarios

=== Iteradores Infinitos

* `std::iter::repeat`
* `std::iter::cycle`
* Cu谩ndo usarlos

'''

== M贸dulo 13: Traits de Conversi贸n

.*Objetivos*: Convertir entre tipos de forma idiom谩tica

=== From y Into

* Trait `From<T>`
* Trait `Into<T>` (implementaci贸n autom谩tica)
* Conversiones sin fallo

=== TryFrom y TryInto

* Conversiones que pueden fallar
* Retornan `Result<T, E>`

=== AsRef y AsMut

* Referencias baratas
* `AsRef<T>` y `AsMut<T>`
* Cu谩ndo usarlos

'''

= NIVEL AVANZADO 

== M贸dulo 14: Traits Avanzados

.*Objetivos*: Dominar el sistema de traits de Rust

=== Associated Types

* `type Item;` en traits
* Diferencia vs gen茅ricos
* Cu谩ndo usar associated types

=== Trait Objects

* `dyn Trait`
* Fat pointers
* Object safety
* Limitaciones

=== Supertraits

* Requerir otros traits
* Sintaxis: `trait A: B + C`

=== Traits del Standard Library

* `Deref` y `DerefMut`
* Operator overloading: `Add`, `Sub`, `Mul`
* `Eq`, `PartialEq`, `Ord`, `PartialOrd`
* `Hash`

'''

== M贸dulo 15: Lifetimes Avanzados

.*Objetivos*: Dominar lifetimes complejos

=== M煤ltiples Lifetimes

* Relaciones entre lifetimes
* Coerci贸n de lifetimes
* Lifetime bounds: `where T: 'a`

=== Higher-Rank Trait Bounds (HRTB)

* Sintaxis: `for<'a>`
* Casos de uso avanzados

=== Lifetime en Traits

* Associated types con lifetimes
* GATs (Generic Associated Types)

=== Subtyping y Variance

* Covariance
* Contravariance
* Invariance

'''

== M贸dulo 16: Smart Pointers

.*Objetivos*: Usar smart pointers avanzados

=== Box<T>

* Heap allocation
* Recursive types
* Trait objects

=== Rc<T> y Arc<T>

* `Rc<T>`: Reference counting (single-threaded)
* `Arc<T>`: Atomic reference counting (multi-threaded)
* `Weak<T>`: Referencias d茅biles

=== RefCell<T> y Cell<T>

* `RefCell<T>`: Interior mutability con verificaci贸n en runtime
* `Cell<T>`: Copy types con interior mutability
* Cu谩ndo usar cada uno

'''

== M贸dulo 17: Concurrencia y Paralelismo

.*Objetivos*: Escribir c贸digo concurrente seguro

=== Threads

* `std::thread::spawn`
* `join()` para sincronizaci贸n
* Ownership en threads
* Thread pools

=== Message Passing

* Channels: `mpsc`
* `Sender` y `Receiver`
* Sincronizaci贸n con mensajes

=== Shared State

* `Mutex<T>`: Mutual exclusion
* `RwLock<T>`: Read-write lock
* `Arc<T>` para compartir entre threads
* Deadlocks y c贸mo evitarlos

=== Atomic Types

* `AtomicBool`, `AtomicI32`, `AtomicUsize`
* Ordering: `Relaxed`, `Acquire`, `Release`, `SeqCst`
* Lock-free programming

=== Traits Send y Sync

* `Send`: Tipos que se pueden mover entre threads
* `Sync`: Tipos que se pueden compartir entre threads

'''

== M贸dulo 18: Async/Await

.*Objetivos*: Escribir c贸digo as铆ncrono eficiente

=== Conceptos de Async

* Diferencia: concurrency vs parallelism
* Async vs threads
* Event loop y runtime

=== Futures

* Trait `Future`
* `Poll`, `Pending`, `Ready`
* Pin y Unpin

=== Sintaxis Async/Await

* `async fn`
* `async` blocks
* Palabra clave `.await`

=== Async Runtimes

* *tokio*: Runtime m谩s usado
* *async-std*: Alternativa
* *smol*: Minimalista

=== Tasks y Spawning

* `tokio::spawn`
* Gesti贸n de tareas
* Cancelaci贸n de tareas

=== Async I/O

* Reading y writing as铆ncrono
* Networking: TCP, UDP
* File I/O as铆ncrono

=== Streams

* `Stream` trait
* Procesamiento de flujos de datos
* Combinators

=== Select y Join

* `tokio::select!`: Esperar m煤ltiples futures
* `tokio::join!`: Ejecutar futures concurrentemente

=== Channels Async

* `tokio::sync::mpsc`
* `tokio::sync::oneshot`
* `tokio::sync::broadcast`

=== Errores Comunes en Async

* Blocking en c贸digo async
* Too many tasks
* Memory leaks con referencias c铆clicas

IMPORTANT: Async Rust es complejo. Practica mucho con proyectos reales.

'''

= NIVEL EXPERTO 

== M贸dulo 19: Macros

.*Objetivos*: Crear macros declarativas y procedurales

=== Macros Declarativas

* `macro_rules!`
* Pattern matching en macros
* Repeticiones: `$(...)*`, `$(...)+`
* Hygiene

=== Macros Derivadas

* `#[derive(...)]` custom
* Crates `syn` y `quote`
* Parsing de AST

=== Attribute Macros

* `#[attribute]` custom
* Modificaci贸n de items

=== Function-like Macros

* `my_macro!(...)`
* Casos de uso

=== Debugging Macros

* `cargo expand`
* Expansi贸n de macros
* Testing de macros

'''

== M贸dulo 20: Unsafe Rust y FFI

.*Objetivos*: Cuando necesitas romper las reglas

=== Unsafe Superpowers

* Dereferencing raw pointers
* Llamar funciones unsafe
* Acceder/modificar statics mutables
* Implementar unsafe traits
* Acceder a fields de unions

=== Raw Pointers

* `*const T` y `*mut T`
* Conversi贸n desde referencias
* Cu谩ndo usar raw pointers

=== Unsafe Traits

* Implementar `Send` y `Sync` manualmente
* Garant铆as de seguridad

=== Interior Mutability Unsafe

* `UnsafeCell<T>`
* Construcci贸n de abstracciones seguras

=== FFI (Foreign Function Interface)

* Llamar c贸digo C desde Rust
* `extern "C"`
* `#[repr(C)]`
* Binding generation con `bindgen`

=== Llamar Rust desde Otros Lenguajes

* `#[no_mangle]`
* Crear bibliotecas din谩micas
* Exportar funciones

=== Librer铆as para FFI

* *cc*: Compilar C/C++ code
* *cmake*: Integraci贸n con CMake
* *pkg-config*

WARNING: Unsafe es peligroso. Solo 煤salo cuando sea absolutamente necesario y documenta por qu茅 es seguro.

'''

== M贸dulo 21: Testing, Benchmarking y Debugging

.*Objetivos*: Calidad y rendimiento del c贸digo

=== Unit Tests

* `#[cfg(test)]` y `#[test]`
* Assertions: `assert!`, `assert_eq!`, `assert_ne!`
* `cargo test`
* Organizaci贸n de tests

=== Integration Tests

* Directorio `tests/`
* Testing de API p煤blica
* Common modules

=== Doc Tests

* Tests en documentation comments
* `cargo test --doc`

=== Test Driven Development (TDD)

* Red-Green-Refactor cycle
* Test first approach

=== Property-Based Testing

* *proptest*: QuickCheck para Rust
* Generaci贸n autom谩tica de test cases

=== Mocking

* *mockall*: Framework de mocking
* Dependency injection

=== Benchmarking

* `cargo bench`
* *criterion*: Microbenchmarking
* An谩lisis estad铆stico
* Flamegraphs

=== Profiling

* `perf` en Linux
* Instruments en macOS
* `cargo flamegraph`
* Memory profiling

=== Debugging

* `dbg!` macro
* GDB y LLDB
* `rust-gdb` y `rust-lldb`
* VS Code debugger

'''

== M贸dulo 22: Optimizaci贸n y Arquitectura

.*Objetivos*: C贸digo production-ready de alto rendimiento

=== Performance Optimization

* Profiling primero
* Evitar allocations innecesarias
* Inline functions
* SIMD programming
* Cache-friendly code

=== Compilation Profiles

* Perfiles personalizados
* LTO (Link-Time Optimization)
* Codegen options
* Profile-guided optimization (PGO)

=== Binary Size Optimization

* Strip symbols
* `opt-level = "z"`
* `lto = true`
* Eliminar dependencias innecesarias

=== Arquitectura de Aplicaciones

* Layered architecture
* Hexagonal architecture
* Domain-driven design
* Clean architecture en Rust

=== Design Patterns

* Builder pattern
* Newtype pattern
* Type state pattern
* Strategy pattern
* Visitor pattern
